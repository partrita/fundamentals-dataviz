```{r echo = FALSE, message = FALSE, warning = FALSE}
# 설정 스크립트 실행
source("_common.R")

library(forcats)
library(lubridate)
library(mgcv)
library(tidyr)
library(purrr)
library(broom)
library(emmeans)
library(ungeviz)
library(ggridges)
library(tidybayes)

animate <- TRUE # 애니메이션 그림을 포함해야 하는지 여부
#animate <- FALSE
```

# 불확실성 시각화하기 {#visualizing-uncertainty}

데이터 시각화의 가장 어려운 측면 중 하나는 불확실성 시각화입니다. 특정 위치에 그려진 데이터 포인트를 보면 실제 데이터 값을 정확하게 나타내는 것으로 해석하는 경향이 있습니다. 데이터 포인트가 실제로 그려지지 않은 곳에 있을 수 있다는 것을 상상하기 어렵습니다. 그러나 이러한 시나리오는 데이터 시각화에서 흔합니다. 우리가 작업하는 거의 모든 데이터 세트에는 약간의 불확실성이 있으며 이 불확실성을 나타내는 방법과 여부를 선택하는 것은 청중이 데이터의 의미를 얼마나 정확하게 인식하는지에 큰 차이를 만들 수 있습니다.

불확실성을 나타내는 데 일반적으로 사용되는 두 가지 접근 방식은 오차 막대와 신뢰대입니다. 이러한 접근 방식은 과학 출판물의 맥락에서 개발되었으며 올바르게 해석하려면 어느 정도의 전문 지식이 필요합니다. 그러나 정확하고 공간 효율적입니다. 예를 들어 오차 막대를 사용하면 단일 그래프에 많은 다른 매개변수 추정치의 불확실성을 표시할 수 있습니다. 그러나 일반 청중의 경우 불확실성에 대한 강력한 직관적 인상을 만드는 시각화 전략이 더 바람직할 것이며, 이는 시각화 정확도가 떨어지거나 데이터 밀도가 낮은 디스플레이를 희생하더라도 마찬가지입니다. 여기서 옵션에는 빈도 프레이밍(여러 가능한 시나리오를 대략적인 비율로 명시적으로 그림) 또는 여러 가능한 시나리오를 순환하는 애니메이션이 포함됩니다.

## 확률을 빈도로 구성하기 {#frequency-framing}

불확실성을 시각화하는 방법을 논의하기 전에 불확실성이 실제로 무엇인지 정의해야 합니다. 미래 사건의 맥락에서 불확실성 개념을 가장 쉽게 직관적으로 파악할 수 있습니다. 동전을 던질 경우 미리 결과를 알 수 없습니다. 최종 결과는 불확실합니다. 그러나 과거 사건에 대해서도 불확실할 수 있습니다. 어제 주방 창문 밖을 정확히 두 번, 오전 8시와 오후 4시에 한 번씩 보았고 오전 8시에는 길 건너편에 빨간 차가 주차되어 있었지만 오후 4시에는 없었다면 8시간 창 동안 어느 시점에서 차가 떠났다고 결론 내릴 수 있지만 정확히 언제인지는 알 수 없습니다. 오전 8시 1분, 오전 9시 30분, 오후 2시 또는 8시간 동안의 다른 시간일 수 있습니다.

수학적으로 우리는 확률 개념을 사용하여 불확실성을 다룹니다. 확률의 정확한 정의는 복잡하며 이 책의 범위를 훨씬 벗어납니다. 그러나 모든 수학적 복잡성을 이해하지 않고도 확률에 대해 성공적으로 추론할 수 있습니다. 실제적으로 관련된 많은 문제의 경우 상대 빈도에 대해 생각하는 것으로 충분합니다. 동전 던지기나 주사위 굴리기와 같은 어떤 종류의 무작위 시행을 수행하고 특정 결과(예: 앞면 또는 6이 나옴)를 찾는다고 가정해 보겠습니다. 이 결과를 *성공*이라고 하고 다른 모든 결과를 *실패*라고 할 수 있습니다. 그러면 성공 확률은 무작위 시행을 반복해서 수행할 경우 해당 결과가 나타나는 횟수의 비율로 대략적으로 주어집니다. 예를 들어 특정 결과가 10%의 확률로 발생하면 여러 번 반복된 시행 중에서 해당 결과가 약 10번 중 1번 나타날 것으로 예상합니다.

단일 확률을 시각화하는 것은 어렵습니다. 복권 당첨 확률이나 공정한 주사위로 6이 나올 확률을 어떻게 시각화하시겠습니까? 두 경우 모두 확률은 단일 숫자입니다. 해당 숫자를 양으로 취급하고 막대 그래프나 점 그림과 같이 챕터 \@ref(visualizing-amounts)에서 논의된 기술 중 하나를 사용하여 표시할 수 있지만 결과는 그다지 유용하지 않습니다. 대부분의 사람들은 확률 값이 경험적 현실로 어떻게 변환되는지에 대한 직관적인 이해가 부족합니다. 확률 값을 막대나 선 위에 놓인 점으로 표시하는 것은 이 문제에 도움이 되지 않습니다.

임의 배열로 여러 색상의 정사각형을 그리는 등 빈도 측면과 무작위 시행의 예측 불가능성을 모두 강조하는 그래프를 만들어 확률 개념을 구체화할 수 있습니다. 그림 \@ref(fig:probability-waffle)에서는 이 기법을 사용하여 세 가지 다른 확률, 즉 1% 성공 확률, 10% 성공 확률, 40% 성공 확률을 시각화합니다. 이 그림을 읽으려면 어떤 정사각형이 어둡고 어떤 정사각형이 밝은지 보기 전에 어두운 정사각형을 선택하는 작업을 맡았다고 상상해 보십시오. (원한다면 눈을 감고 정사각형을 선택한다고 생각할 수 있습니다.) 직관적으로 1% 확률의 경우 어두운 정사각형 하나를 선택하는 것이 거의 불가능하다는 것을 알 수 있을 것입니다. 마찬가지로 10% 확률의 경우에도 어두운 정사각형을 선택하는 것이 상당히 어려울 것입니다. 그러나 40% 확률의 경우 확률이 그렇게 나쁘지 않아 보입니다. 특정 잠재적 결과를 보여주는 이러한 시각화 스타일을 *이산 결과 시각화*라고 하며 확률을 빈도로 시각화하는 행위를 *빈도 프레이밍*이라고 합니다. 우리는 결과의 확률적 특성을 이해하기 쉬운 결과 빈도 측면에서 구성하고 있습니다.

(ref:probability-waffle) 빈도로서의 확률 시각화. 각 격자에는 100개의 정사각형이 있으며 각 정사각형은 어떤 무작위 시행에서 성공 또는 실패를 나타냅니다. 1% 성공 확률은 어두운 정사각형 1개와 밝은 정사각형 99개에 해당하고, 10% 성공 확률은 어두운 정사각형 10개와 밝은 정사각형 90개에 해당하며, 40% 성공 확률은 어두운 정사각형 40개와 밝은 정사각형 60개에 해당합니다. 밝은 정사각형 사이에 어두운 정사각형을 무작위로 배치함으로써 단일 시행 결과의 불확실성을 강조하는 무작위성의 시각적 인상을 만들 수 있습니다.

```{r probability-waffle, fig.width = 5*6/4.2, fig.asp = 1.2/3, fig.cap = '(ref:probability-waffle)'}
g <- expand.grid(x = 1:10, y = 1:10)

set.seed(84524)

data <- data.frame(ratio = c(0.01, 0.1, 0.4)) %>%
  mutate(
    out = purrr::map(
      ratio,
      ~g %>% mutate(
        value = {
          n <- n()
          i <- round(n*.x)
          sample(c(rep("S", i), rep("F", n - i)), n)
        }
      )
    )
  ) %>%
  unnest() %>%
  mutate(
    label = paste0(round(100*ratio), "% 확률")
  )

ggplot(data, aes(x, y, fill = value)) +
  geom_tile(color = "white", size = 1) +
  coord_fixed(expand = FALSE, clip = "off") +
  scale_x_continuous(name = NULL, breaks = NULL) +
  scale_y_continuous(name = NULL, breaks = NULL) +
  scale_fill_manual(
    name = NULL,
    breaks = c("S", "F"),
    labels = c("성공   ", "실패"),
    values = c(
      "S" = desaturate(darken("#0072B2", .4), .5),
      "F" = desaturate(lighten("#0072B2", .7), .5)
    ),
    guide = guide_legend(override.aes = list(size = 0))
  ) +
  facet_wrap(~label) +
  theme_dviz_grid() +
  theme(
    panel.spacing = unit(12, "pt"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "right",
    legend.box.spacing = unit(6, "pt"),
    legend.spacing.x = unit(3, "pt"),
    legend.key.size = unit(10, "pt"),
    plot.margin = margin(0, 0, 3.5, 0) # 플롯을 약간 더 타이트하게 자릅니다.
  )
```

성공 또는 실패라는 두 가지 이산적인 결과에만 관심이 있다면 그림 \@ref(fig:probability-waffle)과 같은 시각화가 잘 작동합니다. 그러나 무작위 시행의 결과가 수치 변수인 더 복잡한 시나리오를 다루는 경우가 많습니다. 일반적인 시나리오 중 하나는 선거 예측이며, 여기서 누가 이길 뿐만 아니라 얼마나 많은 차이로 이길 것인지에 관심이 있습니다. 노란색 정당과 파란색 정당이라는 두 정당이 있는 가상의 다가오는 선거 예를 생각해 보겠습니다. 라디오에서 파란색 정당이 노란색 정당보다 1% 포인트 우세할 것으로 예측되며 오차 범위는 1.76% 포인트라고 들었다고 가정해 보겠습니다. 이 정보는 선거의 가능한 결과에 대해 무엇을 알려줍니까? "파란색 정당이 이길 것이다"라고 듣는 것은 인간의 본성이지만 현실은 더 복잡합니다. 첫째, 가장 중요한 것은 다양한 가능한 결과 범위가 있다는 것입니다. 파란색 정당이 2% 포인트 차이로 이기거나 노란색 정당이 0.5% 포인트 차이로 이길 수 있습니다. 관련 가능성이 있는 가능한 결과 범위는 확률 분포라고 하며 가능한 결과 범위에 걸쳐 상승했다가 하강하는 부드러운 곡선으로 그릴 수 있습니다(그림 \@ref(fig:election-prediction)). 특정 결과에 대한 곡선이 높을수록 해당 결과가 더 가능성이 높습니다. 확률 분포는 챕터 \@ref(histograms-density-plots)에서 논의된 히스토그램 및 커널 밀도와 밀접하게 관련되어 있으므로 해당 장을 다시 읽어 기억을 되살리는 것이 좋습니다.

(ref:election-prediction) 가상 선거 결과 예측. 파란색 정당은 노란색 정당보다 약 1% 포인트 우세할 것으로 예측되지만("최적 추정치"로 표시됨) 해당 예측에는 오차 범위가 있습니다(여기서는 가능한 결과의 95%를 포함하도록 그려졌으며 최적 추정치에서 양방향으로 1.76% 포인트). 파란색으로 음영 처리된 영역은 전체의 87.1%에 해당하며 파란색이 이기는 모든 결과를 나타냅니다. 마찬가지로 노란색으로 음영 처리된 영역은 전체의 12.9%에 해당하며 노란색이 이기는 모든 결과를 나타냅니다. 이 예에서 파란색은 선거에서 이길 확률이 87%입니다.

```{r election-prediction, fig.asp = 0.5, fig.cap = '(ref:election-prediction)'}
x <- c(seq(-2.5, 0, length.out = 50), seq(0.00001, 5, length.out = 100))
mu <- 1.02
sd <- .9

df_norm <- data.frame(
  x,
  y = dnorm(x, mu, sd),
  type = ifelse(x <= 0, "A", "B")
)

ci_x <- c(qnorm(.025, mu, sd), qnorm(0.975, mu, sd))
ci_y <- dnorm(ci_x, mu, sd)

df_annot <- data.frame(
  x = c(mu + 0.05, mu + 0.1, mu + 2.3*sd, mu - 2.5*sd),
  y = c(dnorm(mu, mu, sd) + 0.04, ci_y[1] + 0.01, 3*ci_y[1], 3*ci_y[1]),
  hjust = c(0, 0, 0.5, 0.5),
  vjust = c(1, 0, 0.5, 0.5),
  label = c("최적 추정치", "오차 범위", "파란색 승리", "노란색 승리")
)

ggplot(df_norm, aes(x, y)) +
  geom_area(aes(fill = type)) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_line() +
  geom_segment(
    data = data.frame(x = 1),
    x = ci_x[1], xend = ci_x[2], y = ci_y[1], yend = ci_y[2],
    arrow = arrow(angle = 15, length = grid::unit(9, "pt"), ends = "both", type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_segment(
    data = data.frame(x = 1),
    x = mu, xend = mu, y = 0, yend = dnorm(mu, mu, sd) + 0.04,
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_annot,
    aes(x, y, label = label, hjust = hjust, vjust = vjust),
    family = dviz_font_family,
    size = 12/.pt
  ) +
  scale_x_continuous(
    name = "파란색에 대한 백분율 포인트 우위",
    labels = scales::percent_format(accuracy = 0.1, scale = 1)
  ) +
  scale_y_continuous(
    name = NULL,
    breaks = NULL,
    expand = c(0, 0),
    limits = c(0, dnorm(mu, mu, sd) + 0.045)
  ) +
  scale_fill_manual(
    values = c(A = "#f8f1a9", B = "#b1daf4"),
    guide = "none"
  ) +
  theme_dviz_open()
```

약간의 계산을 통해 가상 예에서 노란색 정당이 이길 확률은 12.9%임을 알 수 있습니다. 따라서 노란색이 이길 확률은 그림 \@ref(fig:probability-waffle)에 표시된 10% 확률 시나리오보다 약간 더 좋습니다. 파란색 정당을 선호한다면 그다지 걱정하지 않을 수도 있지만 노란색 정당은 성공할 만큼 충분한 승리 가능성이 있습니다. 그림 \@ref(fig:election-prediction)을 그림 \@ref(fig:probability-waffle)과 비교하면 그림 \@ref(fig:election-prediction)의 음영 처리된 영역이 파란색 또는 노란색 승리 확률을 정확하게 나타내더라도 그림 \@ref(fig:probability-waffle)이 결과의 불확실성을 훨씬 더 잘 전달한다는 것을 알 수 있습니다. 이것이 이산 결과 시각화의 힘입니다. 인간 인식에 대한 연구에 따르면 우리는 여러 영역의 상대적 크기를 판단하는 것보다 이산적인 개체의 상대적 빈도를 인식하고 계산하고 판단하는 데 훨씬 더 능숙합니다. 단, 총 개수가 너무 많지 않은 경우에 한합니다.

그림 \@ref(fig:probability-waffle)의 이산 결과 특성과 그림 \@ref(fig:election-prediction)과 같은 연속 분포를 결합하여 분위수 점 그림을 그릴 수 있습니다[@Kay_et_al_2016]. 분위수 점 그림에서는 곡선 아래 전체 영역을 균등한 크기의 단위로 세분화하고 각 단위를 원으로 그립니다. 그런 다음 원을 쌓아 원래 분포 곡선을 대략적으로 나타내도록 합니다(그림 \@ref(fig:election-quantile-dot)).

(ref:election-quantile-dot) 그림 \@ref(fig:election-prediction)의 선거 결과 분포의 분위수 점 그림 표현. (a) 부드러운 분포는 각각 2% 확률을 나타내는 50개의 점으로 근사됩니다. 따라서 6개의 노란색 점은 12% 확률에 해당하며 실제 값 12.9%에 상당히 가깝습니다. (b) 부드러운 분포는 각각 10% 확률을 나타내는 10개의 점으로 근사됩니다. 따라서 하나의 노란색 점은 10% 확률에 해당하며 여전히 실제 값에 가깝습니다. 점 수가 적은 분위수 점 그림은 읽기 쉬운 경향이 있으므로 이 예에서는 50개 점 버전보다 10개 점 버전이 더 바람직할 수 있습니다.

```{r election-quantile-dot, fig.asp = 0.72, fig.cap = '(ref:election-quantile-dot)'}
mu <- 1.02
sd <- 0.9
binwidth <- 0.31
binwidth <- 0.29

df_q <- data.frame(x = qnorm(ppoints(50), mu, sd)) %>%
  mutate(type = ifelse(x <= 0, "A", "B"))

p1 <- ggplot(df_q, aes(x, fill = type)) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_line(data = df_norm, aes(x, 1.92*y)) + # 계수 1.92는 수동으로 결정됨
  geom_dotplot(binwidth = binwidth) +
  scale_x_continuous(
    name = NULL, #"파란색에 대한 백분율 포인트 우위",
    labels = scales::percent_format(accuracy = 0.1, scale = 1)
  ) +
  scale_y_continuous(
    name = NULL,
    breaks = NULL,
    expand = c(0, 0),
    limits = c(0, 0.9)
  ) +
  scale_fill_manual(
    values = c(A = "#f8f1a9", B = "#b1daf4"),
    guide = "none"
  ) +
  theme_dviz_open()

binwidth <- 0.31*2.1

df_q <- data.frame(x = qnorm(ppoints(10), mu, sd)) %>%
  mutate(type = ifelse(x <= 0, "A", "B"))

p2 <- ggplot(df_q, aes(x, fill = type)) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_line(data = df_norm, aes(x, 1.92*y)) + # 계수 1.92는 수동으로 결정됨
  geom_dotplot(binwidth = binwidth) +
  scale_x_continuous(
    name = "파란색에 대한 백분율 포인트 우위",
    labels = scales::percent_format(accuracy = 0.1, scale = 1)
  ) +
  scale_y_continuous(
    name = NULL,
    breaks = NULL,
    expand = c(0, 0),
    limits = c(0, 0.9)
  ) +
  scale_fill_manual(
    values = c(A = "#f8f1a9", B = "#b1daf4"),
    guide = "none"
  ) +
  theme_dviz_open()

plot_grid(p1, p2, align = 'h', labels = "auto", ncol = 1)
```

일반적인 원칙으로 분위수 점 그림은 적당한 수의 점을 사용해야 합니다. 점이 너무 많으면 개별적인 이산 단위가 아닌 연속체로 인식하는 경향이 있습니다. 이는 이산 플롯의 장점을 상쇄합니다. 그림 \@ref(fig:election-quantile-dot)는 50개의 점이 있는 변형(그림 \@ref(fig:election-quantile-dot)a)과 10개의 점이 있는 변형(그림 \@ref(fig:election-quantile-dot)b)을 보여줍니다. 50개의 점이 있는 버전은 실제 확률 분포를 더 정확하게 포착하지만 점 수가 너무 많아 개별 점을 쉽게 구별하기 어렵습니다. 10개의 점이 있는 버전은 파란색 또는 노란색이 이길 상대적 확률을 더 즉각적으로 전달합니다. 10개 점 버전에 대한 한 가지 반론은 그다지 정확하지 않다는 것입니다. 노란색이 이길 확률을 2.9% 포인트 과소평가하고 있습니다. 그러나 특히 일반 청중에게 전달할 때 결과 시각화에 대한 더 정확한 인간 인식을 위해 약간의 수학적 정밀도를 희생하는 것이 종종 가치가 있습니다. 수학적으로는 정확하지만 제대로 인식되지 않는 시각화는 실제로는 그다지 유용하지 않습니다.


## 점 추정치의 불확실성 시각화

그림 \@ref(fig:election-prediction)에서는 "최적 추정치"와 "오차 한계"를 보여주었지만 이러한 양이 정확히 무엇인지 또는 어떻게 얻을 수 있는지 설명하지 않았습니다. 이를 더 잘 이해하려면 통계적 표본 추출의 기본 개념을 간략하게 살펴보아야 합니다. 통계학에서 우리의 가장 중요한 목표는 세상의 작은 부분을 살펴봄으로써 세상에 대해 무언가를 배우는 것입니다. 선거 예를 계속 들면 여러 선거구가 있고 각 선거구의 시민들이 파란색 정당이나 노란색 정당에 투표한다고 가정해 보겠습니다. 각 선거구가 어떻게 투표할지, 그리고 선거구 전체의 평균 투표 결과를 예측하고 싶을 수 있습니다. 선거 전에 예측하려면 각 선거구의 모든 개별 시민에게 어떻게 투표할 것인지 설문 조사를 할 수 없습니다. 대신 일부 선거구의 일부 시민을 대상으로 설문 조사를 하고 해당 데이터를 사용하여 최상의 추측을 해야 합니다. 통계 용어로 모든 선거구의 모든 시민의 가능한 투표 총 집합을 *모집단*이라고 하며 우리가 설문 조사하는 시민 및/또는 선거구의 하위 집합을 *표본*이라고 합니다. 모집단은 세상의 기본적이고 진정한 상태를 나타내며 표본은 그 세상으로 통하는 창입니다.

우리는 일반적으로 모집단의 중요한 속성을 요약하는 특정 양에 관심이 있습니다. 선거 예에서는 이것이 선거구 전체의 평균 투표 결과 또는 선거구 결과 간의 표준 편차일 수 있습니다. 모집단을 설명하는 양을 *모수*라고 하며 일반적으로 알 수 없습니다. 그러나 표본을 사용하여 실제 모수 값에 대한 추측을 할 수 있으며 통계학자들은 이러한 추측을 *추정치*라고 합니다. 표본 평균(또는 평균)은 모수인 모집단 평균에 대한 추정치입니다. 개별 모수 값의 추정치를 *점 추정치*라고도 하는데, 각 추정치를 선 위의 점으로 나타낼 수 있기 때문입니다.

그림 \@ref(fig:sampling-schematic)은 이러한 주요 개념이 서로 어떻게 관련되어 있는지 보여줍니다. 관심 변수(예: 각 선거구의 투표 결과)는 모집단에서 모집단 평균과 모집단 표준 편차를 갖는 어떤 분포를 갖습니다. 표본은 특정 관찰값 집합으로 구성됩니다. 표본의 개별 관찰값 수를 *표본 크기*라고 합니다. 표본에서 표본 평균과 표본 표준 편차를 계산할 수 있으며 이는 일반적으로 모집단 평균 및 표준 편차와 다릅니다. 마지막으로 표본 추출 과정을 여러 번 반복하면 얻을 수 있는 추정치 분포인 *표본 분포*를 정의할 수 있습니다. 표본 분포의 너비를 *표준 오차*라고 하며 이는 추정치가 얼마나 정확한지 알려줍니다. 즉, 표준 오차는 모수 추정치와 관련된 불확실성의 척도를 제공합니다. 일반적인 규칙으로 표본 크기가 클수록 표준 오차는 작아지고 따라서 추정치의 불확실성은 줄어듭니다.

(ref:sampling-schematic) 통계적 표본 추출의 주요 개념. 우리가 연구하는 관심 변수는 모집단에서 실제 모집단 평균과 표준 편차를 갖는 어떤 실제 분포를 갖습니다. 해당 변수의 유한한 표본은 모집단 모수와 다른 표본 평균과 표준 편차를 갖습니다. 반복적으로 표본을 추출하고 매번 평균을 계산하면 결과 평균은 평균의 표본 분포에 따라 분포됩니다. 표준 오차는 표본 분포의 너비에 대한 정보를 제공하며, 이는 관심 모수(여기서는 모집단 평균)를 얼마나 정확하게 추정하고 있는지 알려줍니다.

```{r sampling-schematic, fig.asp = 3/4, fig.cap = '(ref:sampling-schematic)'}
fill_color <- lighten("#56B4E9", 0.2)
fill_color <- "lightblue"

set.seed(452061)


empty_theme <- theme_dviz_open(12, rel_small = 1, rel_large = 1) +
  theme(
    axis.line = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(0, "pt")
  )

x <- c(seq(-4, 4, length.out = 200))

df_norm <- data.frame(
  x,
  y = dnorm(x)
)

sd_x <- c(-1, 1)
sd_y <- dnorm(sd_x)

df_annot <- data.frame(
  x = c(0.05, sd_x[2] + 0.04, -Inf),
  y = c(dnorm(0) * 0.4, sd_y[2] * 1.01, Inf), #sd_y[1] * 1.1
  hjust = c(0, 0, 0),
  vjust = c(1, 0.5, 1),
  label = c("평균", "표준 편차", "모집단 분포")
)


p1 <- ggplot(df_norm, aes(x, y)) +
  geom_area(fill = fill_color) +
  geom_segment( # 표준 편차
    data = data.frame(x = 1),
    x = 0, xend = sd_x[2], y = sd_y[1], yend = sd_y[2],
    arrow = arrow(angle = 90, length = grid::unit(3, "pt"), ends = "both", type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_segment( # 평균을 나타내는 수직선
    data = data.frame(x = 1),
    x = 0, xend = 0, y = 0, yend = dnorm(0),
    linetype = 2,
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_annot,
    aes(x, y, label = label, hjust = hjust, vjust = vjust),
    family = dviz_font_family,
    size = c(12, 12, 14)/.pt
  ) +
  scale_x_continuous(
    limits = c(-4, 4), expand = c(0, 0),
    breaks = 0, # 누락된 축선을 수정하기 위한 해결 방법
    name = "관심 변수"
  ) +
  scale_y_continuous(breaks = NULL, name = NULL, expand = expand_scale(mult = c(0, 0.1))) +
  empty_theme +
  theme(axis.line.x = element_line(), axis.title.x = element_text(hjust = 1))

n <- 15
df_sample <- data.frame(
  x = rnorm(n),
  y = 0
)

df_annot2 <- data.frame(
  x = c(mean(df_sample$x) + 0.05, sort(df_sample$x)[2],
        mean(df_sample$x) + sd(df_sample$x) + 0.05, -Inf),
  y = c(-0.15, 0.12, .13 + 0.01, Inf),
  hjust = c(0, 0.3, 0, 0),
  vjust = c(0.5, 0.5, 0.5, 1),
  label = c("표본 평균", "관찰값", "표본 표준 편차", "표본")
)


p2 <- ggplot(df_sample, aes(x, y)) +
  geom_point(
    size = 3, fill = fill_color, shape = 21, stroke = 0.5,
    position = position_jitter(width = 0, height = 0.01, seed = 127)
  ) +
  geom_segment( # 평균을 나타내는 수직 막대
    data = data.frame(x = 1),
    aes(x = mean(df_sample$x), xend = mean(df_sample$x), y = -.2, yend = .2),
    size = 1.5,
    color = "#D55E00",
    inherit.aes = FALSE
  ) +
  geom_segment( # 표준 편차를 나타내는 수평 막대
    data = data.frame(x = 1),
    x = mean(df_sample$x), xend = mean(df_sample$x) + sd(df_sample$x), y = .13, yend = .13,
    arrow = arrow(angle = 90, length = grid::unit(3, "pt"), ends = "both", type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_annot2,
    aes(x, y, label = label, hjust = hjust, vjust = vjust),
    family = dviz_font_family,
    size = c(12, 12, 12, 14)/.pt
  ) +
  scale_x_continuous(limits = c(-4, 4), expand = c(0, 0), breaks = NULL, name = NULL) +
  scale_y_continuous(expand = c(0.1, 0), breaks = NULL, name = NULL) +
  empty_theme

df_samplingdist <- data.frame(
  x,
  y = dnorm(x, 0, 1/sqrt(n))
)

se_x <- c(-1/sqrt(n), 1/sqrt(n))
se_y <- dnorm(se_x, 0, 1/sqrt(n))

df_annot3 <- data.frame(
  x = c(0.05, se_x[2] + 0.04, -Inf),
  y = c(dnorm(0, 0, 1/sqrt(n)) * 0.4, se_y[2] * 1.01, Inf),
  hjust = c(0, 0, 0),
  vjust = c(1, 0.5, 1),
  label = c("표본 평균의 평균", "표준 오차", "평균의 표본 분포")
)

p3 <- ggplot(df_samplingdist, aes(x, y)) +
  geom_area(fill = fill_color) +
  geom_segment( # 표준 오차
    data = data.frame(x = 1),
    x = 0, xend = se_x[2], y = se_y[1], yend = se_y[2],
    arrow = arrow(angle = 90, length = grid::unit(3, "pt"), ends = "both", type = "closed"),
    inherit.aes = FALSE
  ) +
  geom_segment(
    data = data.frame(x = 1),
    x = 0, xend = 0, y = 0, yend = dnorm(0, 0, 1/sqrt(n)),
    linetype = 2,
    inherit.aes = FALSE
  ) +
  geom_text(
    data = df_annot3,
    aes(x, y, label = label, hjust = hjust, vjust = vjust),
    family = dviz_font_family,
    size = c(12, 12, 14)/.pt
  ) +
  scale_x_continuous(
    limits = c(-4, 4), expand = c(0, 0),
    breaks = 0, # 누락된 축선을 수정하기 위한 해결 방법
    name = "표본 평균"
  ) +
  scale_y_continuous(breaks = NULL, name = NULL, expand = expand_scale(mult = c(0, 0.1))) +
  empty_theme +
  theme(axis.line.x = element_line(), axis.title.x = element_text(hjust = 1))

plot_grid(
  p1,
  p2,
  p3,
  ncol = 1, rel_heights = c(1, .4, 1), align = 'v'
)
```

표준 편차와 표준 오차를 혼동하지 않는 것이 중요합니다. 표준 편차는 모집단의 속성입니다. 우리가 할 수 있는 개별 관찰값 사이에 얼마나 많은 분산이 있는지 알려줍니다. 예를 들어 투표 구역 모집단을 고려하면 표준 편차는 여러 구역이 서로 얼마나 다른지 알려줍니다. 반대로 표준 오차는 모수 추정치를 얼마나 정확하게 결정했는지 알려줍니다. 모든 구역의 평균 투표 결과를 추정하려는 경우 표준 오차는 평균 추정치가 얼마나 정확한지 알려줍니다.

모든 통계학자는 표본을 사용하여 모수 추정치와 그 불확실성을 계산합니다. 그러나 이러한 계산에 접근하는 방식에서 베이즈주의자와 빈도주의자로 나뉩니다. 베이즈주의자는 세상에 대한 사전 지식이 있다고 가정하고 표본을 사용하여 이 지식을 업데이트합니다. 반대로 빈도주의자는 사전 지식 없이 세상에 대한 정확한 진술을 하려고 합니다. 다행히 불확실성을 시각화하는 경우 베이즈주의자와 빈도주의자는 일반적으로 동일한 유형의 전략을 사용할 수 있습니다. 여기서는 먼저 빈도주의적 접근 방식을 논의한 다음 베이즈주의적 맥락에 고유한 몇 가지 특정 문제를 설명합니다.

빈도주의자들은 가장 일반적으로 오차 막대를 사용하여 불확실성을 시각화합니다. 오차 막대는 불확실성을 시각화하는 데 유용할 수 있지만 챕터 \@ref(boxplots-violins)에서 이미 언급했듯이(그림 \@ref(fig:lincoln-temp-points-errorbars) 참조) 문제가 없는 것은 아닙니다. 독자가 오차 막대가 무엇을 나타내는지 혼동하기 쉽습니다. 이 문제를 강조하기 위해 그림 \@ref(fig:cocoa-data-vs-CI)에서는 동일한 데이터 세트에 대해 다섯 가지 다른 오차 막대 사용법을 보여줍니다. 데이터 세트에는 여러 다른 국가에서 제조된 초콜릿 바에 대한 전문가 평가(1점에서 5점까지)가 포함되어 있습니다. 그림 \@ref(fig:cocoa-data-vs-CI)의 경우 캐나다에서 제조된 초콜릿 바에 대한 모든 평가를 추출했습니다. 지터 처리된 점의 스트립 차트로 표시된 표본 아래에는 표본 평균 더하기/빼기 표본의 표준 편차, 표본 평균 더하기/빼기 표준 오차, 80%, 95%, 99% 신뢰 구간이 표시됩니다. 다섯 개의 오차 막대는 모두 표본의 변동에서 파생되며 모두 수학적으로 관련되어 있지만 의미는 다릅니다. 그리고 시각적으로도 상당히 다릅니다.

(ref:cocoa-data-vs-CI) 초콜릿 바 평가 예에서 표본, 표본 평균, 표준 편차, 표준 오차 및 신뢰 구간 간의 관계. 표본을 구성하는 관찰값(녹색 점으로 표시됨)은 캐나다 제조업체의 125개 초콜릿 바에 대한 전문가 평가를 나타내며 1점(불쾌함)에서 5점(최상급)까지 평가됩니다. 큰 주황색 점은 평가의 평균을 나타냅니다. 오차 막대는 위에서 아래로 표준 편차의 두 배, 표준 오차(평균의 표준 편차)의 두 배, 평균의 80%, 95%, 99% 신뢰 구간을 나타냅니다. 데이터 출처: 브래디 브렐린스키, 맨해튼 초콜릿 협회

```{r cocoa-data-vs-CI, fig.width = 5*6/4.2, fig.asp = 0.48, warning = FALSE, message = FALSE, fig.cap = '(ref:cocoa-data-vs-CI)'}

# 개별 작은 데이터 포인트의 색상
point_color <- darken("#009E73", .3)

cacao %>%
  filter(location == "캐나다") -> cacao_single

fit <- lm(rating ~ 1, data = cacao_single)

CI_df <- data.frame(type = c(0.8, 0.95, 0.99)) %>%
  mutate(df = map(type, ~tidy(emmeans(fit, ~ 1, options = list(level = .x))))) %>%
  unnest() %>%
  select(type, estimate, std.error, conf.low, conf.high) %>%
  mutate(type = paste0(signif(100*type, 2), "% 신뢰 구간"))

CI_df <- rbind(
  CI_df,
  data.frame(
    type = "표준 오차",
    estimate = CI_df$estimate[1],
    std.error = CI_df$std.error[1],
    conf.low = CI_df$estimate[1] - CI_df$std.error[1],
    conf.high = CI_df$estimate[1] + CI_df$std.error[1]
  ),
  data.frame(
    type = "표준 편차",
    estimate = mean(cacao_single$rating),
    std.error = CI_df$std.error[1],
    conf.low = mean(cacao_single$rating) - sd(cacao_single$rating),
    conf.high = mean(cacao_single$rating) + sd(cacao_single$rating)
  ),
  data.frame(
    type = "표본", estimate = mean(cacao_single$rating), std.error = NA,
    conf.low = NA, conf.high = max(cacao_single$rating)
  )
) %>%
  mutate(
    type = fct_relevel(factor(type), "표본", "표준 편차", "표준 오차"),
    label = case_when(
      type == "표본" ~ NA_character_,
      type == "표준 편차" ~ "+/- 표준 편차",
      type == "표준 오차" ~ "+/- 표준 오차",
      TRUE ~ as.character(type) #paste0("평균 +/- ", type)
    )
  )

label_x <- filter(CI_df, type == "표준 편차")$conf.high + 0.04

ggplot(CI_df, aes(estimate, type)) +
  geom_point(
    data = cacao_single, aes(rating, "표본"),
    position = position_jitter(height = 0.6, width = 0.02, seed = 7843),
    color = point_color,
    size = 0.3
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2, na.rm = TRUE) +
  geom_point(size = 2, color = "#D55E00") +
  geom_label(
    aes(label_x, label = label), hjust = 0, nudge_y = 0.01, na.rm = TRUE,
    family = dviz_font_family,
    size = 14/.pt,
    label.size = 0
  ) +
  geom_label(
    data = filter(CI_df, type == "표본"),
    aes(conf.high + 0.06, label = type), hjust = 0, nudge_y = 0.01,
    family = dviz_font_family,
    size = 14/.pt,
    label.size = 0
  ) +
  geom_text(
    data = filter(CI_df, type == "표본"),
    aes(estimate, label = "평균"), hjust = 0.2, vjust = 0, nudge_y = 0.2,
    family = dviz_font_family,
    size = 14/.pt
  ) +
  scale_x_continuous(
    limits = c(1.95, 4.1),
    expand = c(0, 0),
    name = "초콜릿 맛 평가"
  ) +
  scale_y_discrete(
    name = NULL,
    limits = rev(levels(CI_df$type)),
    expand = expand_scale(add = c(0.6, 0.8)),
    breaks = NULL
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_vgrid(14, rel_small = 1) +
  theme(
    plot.margin = margin(3, 82, 3, 1.5),
    axis.line.x = element_line(),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1)
  )

```


```{block type='rmdtip', echo=TRUE}
오차 막대로 불확실성을 시각화할 때는 항상 오차 막대가 나타내는 양 및/또는 신뢰 수준을 지정해야 합니다.
```

표준 오차는 대략 표본 표준 편차를 표본 크기의 제곱근으로 나눈 값으로 주어지며 신뢰 구간은 표준 오차에 작은 상수 값을 곱하여 계산됩니다. 예를 들어 95% 신뢰 구간은 평균에서 양방향으로 표준 오차의 약 2배만큼 확장됩니다. 따라서 표본 크기가 클수록 표준 편차는 동일하더라도 표준 오차와 신뢰 구간은 좁아지는 경향이 있습니다. 캐나다산 초콜릿 바와 스위스산 초콜릿 바의 평가를 비교할 때 이러한 효과를 볼 수 있습니다(그림 \@ref(fig:cocoa-CI-vs-n)). 캐나다산 초콜릿 바와 스위스산 초콜릿 바의 평균 평가와 표본 표준 편차는 비슷하지만 캐나다산 바는 125개, 스위스산 바는 38개만 평가되었으므로 스위스산 바의 평균에 대한 신뢰 구간이 캐나다산 바의 평균에 대한 신뢰 구간보다 훨씬 넓습니다.

(ref:cocoa-CI-vs-n) 표본 크기가 작을수록 신뢰 구간이 넓어집니다. 캐나다와 스위스의 초콜릿 바는 평균 평가와 표준 편차가 비슷합니다(단순한 검은색 오차 막대로 표시됨). 그러나 스위스 바보다 캐나다 바가 3배 이상 많이 평가되었으므로 스위스 평가 평균에 대한 신뢰 구간(여러 색상과 두께의 오차 막대를 서로 겹쳐 그린 것으로 표시됨)이 캐나다 평가 평균에 대한 신뢰 구간보다 훨씬 넓습니다. 데이터 출처: 브래디 브렐린스키, 맨해튼 초콜릿 협회

```{r cocoa-CI-vs-n, fig.width = 5*6/4.2, fig.asp = 0.46, warning = FALSE, message = FALSE, fig.cap = '(ref:cocoa-CI-vs-n)'}
cacao_CA <- filter(cacao, location == "캐나다")
cacao_CH <- filter(cacao, location == "스위스")

fit_CA <- lm(rating ~ 1, data = cacao_CA)
fit_CH <- lm(rating ~ 1, data = cacao_CH)

CI_CA <- data.frame(level = c(0.99, 0.95, 0.8)) %>%
  mutate(df = map(level, ~tidy(emmeans(fit_CA, ~ 1, options = list(level = .x))))) %>%
  unnest() %>%
  select(level, estimate, conf.low, conf.high) %>%
  mutate(
    level = paste0(signif(100*level, 2), "%"),
    type = "CI",
    location = "캐나다"
  )

CI_CH <- data.frame(level = c(0.99, 0.95, 0.8)) %>%
  mutate(df = map(level, ~tidy(emmeans(fit_CH, ~ 1, options = list(level = .x))))) %>%
  unnest() %>%
  select(level, estimate, conf.low, conf.high) %>%
  mutate(
    level = paste0(signif(100*level, 2), "%"),
    type = "CI",
    location = "스위스"
  )

CI_df <- rbind(CI_CA, CI_CH)

sd_df <- rbind(
  data.frame(
    level = NA,
    estimate = mean(cacao_CA$rating),
    conf.low = mean(cacao_CA$rating) - sd(cacao_CA$rating),
    conf.high = mean(cacao_CA$rating) + sd(cacao_CA$rating),
    type = "원본 데이터",
    location = "캐나다"
  ),
  data.frame(
    level = NA,
    estimate = mean(cacao_CH$rating),
    conf.low = mean(cacao_CH$rating) - sd(cacao_CH$rating),
    conf.high = mean(cacao_CH$rating) + sd(cacao_CH$rating),
    type = "원본 데이터",
    location = "스위스"
  )
)

#label_x <- filter(CI_df, type == "표준 편차")$conf.high + 0.04

ggplot(rbind(CI_df, sd_df), aes(estimate, interaction(location, type))) +
  geom_point(
    data = cacao_CA, # 지터링을 이전 그림과 올바르게 맞추기 위해 두 개의 개별 레이어 그리기
    aes(rating, interaction(location, "원본 데이터")),
    position = position_jitter(height = 0.6, width = 0.02, seed = 7843),
    color = point_color,
    size = 0.3
  ) +
  geom_point(
    data = cacao_CH,
    aes(rating, interaction(location, "원본 데이터")),
    position = position_jitter(height = 0.6, width = 0.02, seed = 7844),
    color = point_color,
    size = 0.3
  ) +
  geom_errorbarh(
    data = sd_df,
    aes(y = interaction(location, "원본 데이터"), xmin = conf.low, xmax = conf.high),
    height = 0.2
  ) +
  geom_errorbarh( # 캡 없는 오차 막대
    data = CI_df,
    aes(y = interaction(location, "CI"), xmin = conf.low, xmax = conf.high, color = level, size = level),
    height = 0
  ) +
  geom_errorbarh( # 캡 있는 오차 막대
    data = CI_df,
    aes(y = interaction(location, "CI"), xmin = conf.low, xmax = conf.high, color = level),
    height = 0.2
  ) +
  geom_point(size = 2, color = "#D55E00") +
  geom_label(
    data = data.frame(
      estimate = 4.06,
      location = c("캐나다", "스위스"),
      type = "원본 데이터",
      label = c(
        paste0("캐나다,\nn = ", nrow(cacao_CA)),
        paste0("스위스,\nn = ", nrow(cacao_CH))
      )
    ),
    aes(label = label), hjust = 0, vjust = 0.5, nudge_y = 0.01,
    family = dviz_font_family,
    size = 14/.pt,
    label.size = 0
  ) +
  scale_x_continuous(
    limits = c(1.95, 4.1),
    expand = c(0, 0),
    name = "초콜릿 맛 평가"
  ) +
  scale_y_discrete(
    name = NULL,
    limits = rev(c("Canada.original data", "Canada.CI", "dummy", "Switzerland.original data", "Switzerland.CI")),
    expand = expand_scale(add = c(1, 0.8)),
    breaks = NULL
  ) +
  scale_fill_manual(
    aesthetics = c("color", "fill"),
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(darken("#0072B2", .2), .3),
     `95%` = desaturate(lighten("#0072B2", .2), .3),
     `99%` = desaturate(lighten("#0072B2", .4), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_size_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = 2.25,
     `95%` = 1.5,
     `99%` = .75
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_vgrid(14, rel_small = 1) +
  theme(
    plot.margin = margin(3, 82, 3, 1.5),
    axis.line.x = element_line(),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1),
    legend.position = c(0, 0.01),
    legend.justification = c(0, 0),
    legend.key.height = grid::unit(7, "pt"),
    legend.key.width = grid::unit(35, "pt"),
    legend.spacing.x = grid::unit(7, "pt"),
    legend.spacing.y = grid::unit(3.5, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )

```

그림 \@ref(fig:cocoa-CI-vs-n)에서는 여러 신뢰 구간을 동시에 표시하며 낮은 신뢰 수준을 나타내는 구간에 더 어두운 색상과 더 두꺼운 선을 사용합니다. 저는 이러한 시각화를 *등급 오차 막대*라고 부릅니다. 등급은 독자가 여러 가능성 범위가 있다는 것을 인식하는 데 도움이 됩니다. 단순한 오차 막대(등급 없음)를 여러 사람에게 보여주면 적어도 일부는 오차 막대를 결정론적으로 인식할 가능성이 높습니다. 예를 들어 데이터의 최소값과 최대값을 나타내는 것으로 인식하거나 오차 막대가 가능한 매개변수 추정치 범위를 나타낸다고 생각할 수 있습니다. 즉, 추정치가 오차 막대 밖으로 벗어날 수 없다고 생각할 수 있습니다. 이러한 유형의 오인식을 *결정론적 해석 오류*라고 합니다. 결정론적 해석 오류의 위험을 최소화할수록 불확실성 시각화가 더 좋아집니다.

오차 막대는 많은 추정치와 그 불확실성을 한 번에 표시할 수 있기 때문에 편리합니다. 따라서 일반적으로 전문가 청중에게 많은 양의 정보를 전달하는 것이 주요 목표인 과학 출판물에 일반적으로 사용됩니다. 이러한 유형의 응용 프로그램의 예로 그림 \@ref(fig:mean-chocolate-ratings)는 6개국의 초콜릿 바에 대한 평균 초콜릿 등급과 관련 신뢰 구간을 보여줍니다.

(ref:mean-chocolate-ratings) 6개국의 제조업체에서 생산한 초콜릿 바의 평균 초콜릿 맛 평가 및 관련 신뢰 구간. 데이터 출처: 브래디 브렐린스키, 맨해튼 초콜릿 협회

```{r mean-chocolate-ratings, fig.width = 5*6/4.2, fig.asp = 0.5, fig.cap = '(ref:mean-chocolate-ratings)'}
#countries <- c("오스트리아", "벨기에", "캐나다", "페루", "스위스")
#
cacao_small <-
  cacao_small %>%
  mutate(location = fct_recode(location, US = "미국")) # 오라일리 스타일로 변경

fit <- lm(rating ~ location, data = cacao_small)

conf_df <- data.frame(level = c(0.99, 0.95, 0.8)) %>%
  mutate(df = map(level, ~tidy(emmeans(fit, ~location, options = list(level = .x))))) %>%
  unnest() %>%
  select(level, location, estimate, std.error, conf.low, conf.high) %>%
  mutate(level = paste0(signif(100*level, 2), "%"))

ggplot(conf_df, aes(estimate, reorder(location, estimate))) +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level, size = level),
    height = 0
  ) +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level),
    height = 0.2
  ) +
  geom_point(data = filter(conf_df, level == "80%"), size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    limits = c(2.6, 3.6),
#    expand = c(0, 0),
    name = "평균 평가"
  ) +
 scale_y_discrete(
#    position = "right",
#    limits = rev(c("Canada.original data", "Canada.CI", "Switzerland.original data", "Switzerland.CI")),
#    breaks = NULL,
   name = NULL
  ) +
  scale_color_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(darken("#0072B2", .2), .3),
     `95%` = desaturate(lighten("#0072B2", .2), .3),
     `99%` = desaturate(lighten("#0072B2", .4), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_size_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = 2.25,
     `95%` = 1.5,
     `99%` = 0.75
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(14, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1),
    legend.position = c(1, 0.01),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(7, "pt"),
    legend.key.width = grid::unit(35, "pt"),
    legend.spacing.x = grid::unit(7, "pt"),
    legend.spacing.y = grid::unit(3.5, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )

```

그림 \@ref(fig:mean-chocolate-ratings)을 보면 평균 평점의 차이에 대해 무엇을 알 수 있는지 궁금할 수 있습니다. 캐나다, 스위스, 오스트리아 바의 평균 평점은 미국 바의 평균 평점보다 높지만 이러한 평균 평점의 불확실성을 고려할 때 평균 차이가 *유의미*한가요? 여기서 "유의미한"이라는 단어는 통계학자들이 사용하는 전문 용어입니다. 관찰된 차이가 무작위 표본 추출로 인해 발생했다는 가정을 어느 정도 신뢰 수준으로 기각할 수 있는 경우 차이가 유의미하다고 합니다. 캐나다 및 미국 바의 유한한 수만 평가되었으므로 평가자는 우연히 더 나은 캐나다 바를 더 많이 고려하고 더 나은 미국 바를 덜 고려했을 수 있으며 이러한 무작위 기회는 캐나다 바가 미국 바보다 체계적으로 높은 평가를 받는 것처럼 보일 수 있습니다.

그림 \@ref(fig:mean-chocolate-ratings)에서 유의성을 평가하기는 어렵습니다. 캐나다 평균 평점과 미국 평균 평점 모두 불확실성이 있기 때문입니다. 평균이 다른지 여부에 대한 질문에는 두 불확실성 모두 중요합니다. 통계 교과서와 온라인 튜토리얼에서는 때때로 오차 막대가 겹치는지 여부에 따라 유의성을 판단하는 방법에 대한 경험 법칙을 게시합니다. 그러나 이러한 경험 법칙은 신뢰할 수 없으므로 피해야 합니다. 평균 평점에 차이가 있는지 평가하는 올바른 방법은 차이에 대한 신뢰 구간을 계산하는 것입니다. 이러한 신뢰 구간이 0을 제외하면 해당 신뢰 수준에서 차이가 유의미하다는 것을 알 수 있습니다. 초콜릿 평점 데이터 세트의 경우 캐나다산 바만 미국산 바보다 유의미하게 높은 평점을 받았습니다(그림 \@ref(fig:chocolate-ratings-contrasts)). 스위스산 바의 경우 차이에 대한 95% 신뢰 구간이 0 값을 간신히 포함합니다. 따라서 미국산 초콜릿 바와 스위스산 초콜릿 바의 평균 평점 차이는 5% 수준에서 간신히 유의미하지 않습니다. 마지막으로 오스트리아산 바가 미국산 바보다 체계적으로 높은 평균 평점을 갖는다는 증거는 전혀 없습니다.

(ref:chocolate-ratings-contrasts) 5개국의 제조업체에서 생산한 초콜릿 바의 평균 초콜릿 맛 평가, 미국 초콜릿 바의 평균 평가 대비. 캐나다 초콜릿 바는 미국 바보다 유의미하게 높은 평가를 받았습니다. 다른 4개국의 경우 미국과 평균 평가에 유의미한 차이가 95% 신뢰 수준에서 없습니다. 신뢰 수준은 더넷 방법을 사용하여 다중 비교에 대해 조정되었습니다. 데이터 출처: 브래디 브렐린스키, 맨해튼 초콜릿 협회

```{r chocolate-ratings-contrasts, fig.width = 5*6/4.2, fig.asp = 0.5, fig.cap = '(ref:chocolate-ratings-contrasts)'}
# 대비를 위한 참조 격자 필요
fit_rg <- ref_grid(fit)

contrasts_dunnettx <- data.frame(level = c(0.99, 0.95, 0.8)) %>%
  mutate(
    df = map(
      level,
      ~data.frame(confint(contrast(fit_rg, method = "trt.vs.ctrl1"), level = .x))
    )
  ) %>%
  unnest() %>%
  select(level, contrast, estimate, std.error = SE, conf.low = lower.CL, conf.high = upper.CL) %>%
  mutate(
    level = paste0(signif(100*level, 2), "%"),
    contrast = stringr::str_extract(as.character(contrast), "[a-zA-Z]+")
  )

ggplot(contrasts_dunnettx, aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level, size = level),
    height = 0
  ) +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level),
    height = 0.2
  ) +
  geom_point(data = filter(contrasts_dunnettx, level == "80%"), size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    name = "평균 평가 차이",
    sec.axis = dup_axis(
      name = NULL,
      breaks = 0,
      labels = "미국 평균 평가"
    )
  ) +
  scale_y_discrete(
    name = NULL
  ) +
  scale_color_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(darken("#0072B2", .2), .3),
     `95%` = desaturate(lighten("#0072B2", .2), .3),
     `99%` = desaturate(lighten("#0072B2", .4), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_size_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = 2.25,
     `95%` = 1.5,
     `99%` = 0.75
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(14, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50"),
    #axis.title.x = element_text(hjust = 1),
    legend.position = c(1, 0.02),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(7, "pt"),
    legend.key.width = grid::unit(35, "pt"),
    legend.spacing.x = grid::unit(7, "pt"),
    legend.spacing.y = grid::unit(3.5, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )

```

이전 그림에서는 등급이 매겨진 오차 막대와 단순한 오차 막대의 두 가지 다른 유형을 사용했습니다. 더 많은 변형이 가능합니다. 예를 들어 끝에 캡이 있거나 없는 오차 막대를 그릴 수 있습니다(그림 \@ref(fig:confidence-visualizations)a, c 대 그림 \@ref(fig:confidence-visualizations)b, d). 이러한 모든 선택에는 장단점이 있습니다. 등급이 매겨진 오차 막대는 여러 신뢰 수준에 해당하는 여러 범위의 존재를 강조합니다. 그러나 이러한 추가 정보의 이면에는 시각적 노이즈가 추가된다는 단점이 있습니다. 그림이 얼마나 복잡하고 정보 밀도가 높은지에 따라 등급이 매겨진 오차 막대보다 단순한 오차 막대가 더 바람직할 수 있습니다. 캡이 있거나 없는 오차 막대를 그릴지 여부는 주로 개인적인 취향의 문제입니다. 캡은 오차 막대가 정확히 어디에서 끝나는지 강조하는 반면(그림 \@ref(fig:confidence-visualizations)a, c) 캡이 없는 오차 막대는 간격의 전체 범위에 동일한 강조를 둡니다(그림 \@ref(fig:confidence-visualizations)b, d). 또한 캡은 시각적 노이즈를 추가하므로 오차 막대가 많은 그림에서는 캡을 생략하는 것이 더 바람직할 수 있습니다.

(ref:confidence-visualizations) 4개국의 제조업체에서 생산한 초콜릿 바의 평균 초콜릿 맛 평가, 미국 초콜릿 바의 평균 평가 대비. 각 패널은 동일한 불확실성 정보를 시각화하는 다른 접근 방식을 사용합니다. (a) 캡이 있는 등급 오차 막대. (b) 캡이 없는 등급 오차 막대. (c) 캡이 있는 단일 간격 오차 막대. (d) 캡이 없는 단일 간격 오차 막대. (e) 신뢰 구간. (f) 신뢰 분포.

```{r confidence-visualizations, fig.width = 5.5*6/4.2, fig.asp = 0.75, fig.cap = '(ref:confidence-visualizations)'}
cacao_smaller <- filter(cacao_small, location != "스위스")

fit <- lm(rating ~ location, data = cacao_smaller)
fit_rg <- ref_grid(fit)

contrasts_dunnettx <- data.frame(level = c(0.99, 0.95, 0.8)) %>%
  mutate(
    df = map(
      level,
      ~data.frame(confint(contrast(fit_rg, method = "trt.vs.ctrl1"), level = .x))
    )
  ) %>%
  unnest() %>%
  select(level, contrast, estimate, std.error = SE, conf.low = lower.CL, conf.high = upper.CL) %>%
  mutate(
    level = paste0(signif(100*level, 2), "%"),
    contrast = stringr::str_extract(as.character(contrast), "[a-zA-Z]+")
  )

p1 <- ggplot(contrasts_dunnettx, aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level, size = level),
    height = 0
  ) +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level),
    height = 0.2
  ) +
  geom_point(data = filter(contrasts_dunnettx, level == "80%"), size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  scale_color_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(darken("#0072B2", .2), .3),
     `95%` = desaturate(lighten("#0072B2", .2), .3),
     `99%` = desaturate(lighten("#0072B2", .4), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_size_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = 1.5,
     `95%` = 1,
     `99%` = 0.5
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50"),
    #axis.title.x = element_text(hjust = 1),
    legend.position = "none",
    #legend.position = c(1, .01),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(6, "pt"),
    legend.key.width = grid::unit(30, "pt"),
    legend.spacing.x = grid::unit(6, "pt"),
    legend.spacing.y = grid::unit(3, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )

p2 <- ggplot(filter(contrasts_dunnettx, level == "95%"),
             aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high),
    height = 0.2
  ) +
  geom_point(size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50")
  )

p3 <- ggplot(contrasts_dunnettx, aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high, color = level, size = level),
    height = 0
  ) +
  geom_point(data = filter(contrasts_dunnettx, level == "80%"), size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  scale_color_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(darken("#0072B2", .2), .3),
     `95%` = desaturate(lighten("#0072B2", .2), .3),
     `99%` = desaturate(lighten("#0072B2", .4), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_size_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = 1.5,
     `95%` = 1,
     `99%` = 0.5
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50"),
    #axis.title.x = element_text(hjust = 1),
    legend.position = "none",
    #legend.position = c(1, .01),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(6, "pt"),
    legend.key.width = grid::unit(24, "pt"),
    legend.spacing.x = grid::unit(6, "pt"),
    legend.spacing.y = grid::unit(3, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )

p4 <- ggplot(filter(contrasts_dunnettx, level == "95%"),
             aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  geom_errorbarh(
    aes(xmin = conf.low, xmax = conf.high),
    height = 0
  ) +
  geom_point(size = 2.5, color = "#D55E00") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50")
  )


p5 <- ggplot(filter(contrasts_dunnettx, level == "95%"),
             aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  stat_confidence_density(
    aes(moe = conf.high-estimate, fill = stat(ndensity)),
    height = 0.7,
    confidence = 0.95,
    alpha = NA
  ) +
  geom_segment(
    aes(
      x = estimate, xend = estimate,
      y = as.integer(reorder(contrast, estimate)) - 0.35,
      yend = as.integer(reorder(contrast, estimate)) + 0.35
    ),
    size = 2, color = "#D55E00"
  ) +
  scale_fill_gradient(low = "#81A7D600", high = "#345A7FD0") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50")
  )


p6 <- ggplot(filter(contrasts_dunnettx, level == "95%"),
             aes(x = estimate, y = reorder(contrast, estimate))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray50") +
  stat_confidence_density(
    aes(moe = conf.high-estimate, height = stat(density)),
    geom = "ridgeline",
    confidence = 0.95,
    scale = 0.2,
    min_height = 0.001,
    alpha = 0.7,
    fill = "#81A7D6",
    size = 0.4
  ) +
  geom_segment(
    aes(
      x = estimate, xend = estimate,
      y = as.integer(reorder(contrast, estimate)) - 0.2,
      yend = as.integer(reorder(contrast, estimate)) + 0.5
    ),
    size = 2, color = "#D55E00"
  ) +
  scale_fill_gradient(low = "#81A7D600", high = "#345A7FD0") +
  scale_x_continuous(
    name = "평균 평가 차이",
    limits = c(-.65, .47),
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.line.x.top = element_blank(),
    axis.ticks.x = element_line(color = "black"),
    axis.ticks.x.top = element_line(color = "gray50"),
    axis.text.y = element_text(vjust = 0)
  )

plot_grid(
  p1, NULL, p3,
  NULL, NULL, NULL,
  p2, NULL, p4,
  NULL, NULL, NULL,
  p5, NULL, p6,
  ncol = 3,
  labels = c("a", "", "b", "", "", "", "c", "", "d", "", "", "", "e", "", "f"),
  rel_widths = c(1, .02, 1),
  rel_heights = c(1, .02, 1, .02, 1)
)
```

오차 막대 대신 점차 사라지는 신뢰 구간을 그릴 수 있습니다(그림 \@ref(fig:confidence-visualizations)e). 신뢰 구간은 여러 가능한 값이 얼마나 가능성이 있는지에 대한 명확한 시각적 감각을 제공하지만 읽기가 어렵습니다. 특정 신뢰 수준이 어디에서 끝나는지 결정하려면 여러 색상 음영을 시각적으로 통합해야 합니다. 그림 \@ref(fig:confidence-visualizations)e에서 페루 초콜릿 바의 평균 평점이 미국 초콜릿 바의 평균 평점보다 유의미하게 낮다고 결론을 내릴 수 있지만 실제로는 그렇지 않습니다. 명시적인 신뢰 분포를 표시할 때도 유사한 문제가 발생합니다(그림 \@ref(fig:confidence-visualizations)f). 곡선 아래 면적을 시각적으로 통합하고 특정 신뢰 수준이 정확히 어디에 도달하는지 결정하기가 어렵습니다. 그러나 이 문제는 그림 \@ref(fig:election-quantile-dot)에서와 같이 분위수 점 그림을 그려 다소 완화할 수 있습니다.

단순한 2D 그림의 경우 오차 막대는 불확실성에 대한 더 복잡한 표시보다 한 가지 중요한 장점이 있습니다. 여러 다른 유형의 플롯과 결합할 수 있다는 것입니다. 거의 모든 시각화에 대해 오차 막대를 추가하여 불확실성을 어느 정도 표시할 수 있습니다. 예를 들어 오차 막대가 있는 막대 그래프를 그려 불확실성이 있는 양을 표시할 수 있습니다(그림 \@ref(fig:butterfat-bars)). 이러한 유형의 시각화는 과학 출판물에서 일반적으로 사용됩니다. 또한 산점도에서 *x* 및 *y* 방향 모두를 따라 오차 막대를 그릴 수도 있습니다(그림 \@ref(fig:median-age-income)).

(ref:butterfat-bars) 네 가지 소 품종 우유의 평균 유지방 함량. 오차 막대는 평균의 표준 오차 +/-를 나타냅니다. 이러한 유형의 시각화는 과학 문헌에서 자주 볼 수 있습니다. 기술적으로는 정확하지만 각 범주 내의 변동이나 표본 평균의 불확실성을 특별히 잘 나타내지는 못합니다. 개별 품종 내 유지방 함량 변동은 그림 \@ref(fig:butterfat-densitites)를 참조하십시오. 데이터 출처: 캐나다 순종 젖소 생산 능력 기록

```{r butterfat-bars, fig.width = 5, fig.cap = '(ref:butterfat-bars)'}
cows %>% filter(breed != "캐나다산") %>%
  mutate(breed = as.character(breed)) %>%
  group_by(breed) %>%
  summarize(
    mean = mean(butterfat),
    se = sd(butterfat)/sqrt(n())
  ) %>%
  mutate(breed = fct_reorder(factor(breed), desc(mean)))-> cow_means

ggplot(cow_means, aes(x = breed, y = mean, ymin = mean - 1.96*se, ymax = mean + 1.96*se)) +
  geom_col(fill = "#56B4E9", alpha = 0.7, width = 0.7) +
  #geom_linerange(size = 0.75) +
  geom_errorbar(size = 0.5, width = 0.1) +
  scale_x_discrete(
    labels = c("저지", "건지", "에어셔", "홀스타인-\n프리지안"),
    name = NULL
  ) +
  scale_y_continuous(
    name = "평균 유지방 함량", expand = c(0, 0),
    labels = scales::percent_format(accuracy = 1, scale = 1)
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(axis.line.x = element_blank())
```

(ref:median-age-income) 펜실베이니아 67개 카운티의 중간 소득 대 중간 연령. 오차 막대는 90% 신뢰 구간을 나타냅니다. 데이터 출처: 2015년 5개년 미국 지역사회 조사

```{r median-age-income, fig.width = 5, fig.asp = 3/4, fig.cap = '(ref:median-age-income)'}
filter(US_income_age, state == "펜실베이니아") %>%
  ggplot(aes(age, income)) +
  geom_errorbarh(
    aes(xmin = age - age.moe, xmax = age + age.moe),
    height = 0,
    color = "#0072B2"
  ) +
  geom_errorbar(
    aes(ymin = income - income.moe, ymax = income + income.moe),
    width = 0,
    color = "#0072B2"
  ) +
  geom_point(color = "#0072B2", size = 0.7) +
  scale_x_continuous(name = "중간 연령 (세)") +
  scale_y_continuous(
    name = "중간 소득 (USD)",
    labels = scales::dollar
  ) +
  theme_dviz_open()
```

빈도주의자와 베이즈주의자라는 주제로 돌아가 보겠습니다. 빈도주의자는 신뢰 구간으로 불확실성을 평가하는 반면 베이즈주의자는 *사후 분포*와 *신뢰 구간*을 계산합니다. 베이즈 사후 분포는 입력 데이터를 고려할 때 특정 모수 추정치가 얼마나 가능성이 있는지 알려줍니다. 신뢰 구간은 사후 분포에서 계산된 특정 확률로 모수 값이 존재할 것으로 예상되는 값의 범위를 나타냅니다. 예를 들어 95% 신뢰 구간은 사후 분포의 중앙 95%에 해당합니다. 실제 모수 값은 95% 신뢰 구간에 있을 확률이 95%입니다.

통계학자가 아니라면 신뢰 구간에 대한 제 정의에 놀랄 수 있습니다. 실제로 신뢰 구간의 정의라고 생각했을 수도 있습니다. 그렇지 않습니다. 베이즈 신뢰 구간은 실제 모수 값이 어디에 있을 가능성이 있는지 알려주고 빈도주의 신뢰 구간은 실제 모수 값이 어디에 없을 가능성이 있는지 알려줍니다. 이러한 구분이 의미론처럼 보일 수 있지만 두 접근 방식 사이에는 중요한 개념적 차이가 있습니다. 베이즈 접근 방식에서는 데이터와 연구 중인 시스템에 대한 사전 지식(사전 분포라고 함)을 사용하여 실제 모수 값이 어디에 있을 것으로 예상되는지 알려주는 확률 분포(사후 분포)를 계산합니다. 반대로 빈도주의 접근 방식에서는 먼저 반증하려는 가정을 세웁니다. 이 가정을 *귀무 가설*이라고 하며 종종 모수가 0과 같다는 가정(예: 두 조건 간에 차이가 없음)입니다. 그런 다음 귀무 가설이 참인 경우 무작위 표본 추출이 관찰된 것과 유사한 데이터를 생성할 확률을 계산합니다. 신뢰 구간은 이 확률의 표현입니다. 특정 신뢰 구간이 귀무 가설 하의 모수 값(즉, 값 0)을 제외하면 해당 신뢰 수준에서 귀무 가설을 기각할 수 있습니다. 또는 신뢰 구간을 반복적인 표본 추출 하에서 지정된 가능성으로 실제 모수 값을 포착하는 간격으로 생각할 수 있습니다(그림 \@ref(fig:ci-frequentist-expl)). 따라서 실제 모수 값이 0이라면 95% 신뢰 구간은 분석된 표본의 5%에서만 0을 제외합니다.

(ref:ci-frequentist-expl) 신뢰 구간의 빈도 해석. 신뢰 구간(CI)은 반복적인 표본 추출의 맥락에서 가장 잘 이해됩니다. 각 표본에 대해 특정 신뢰 구간은 실제 모수(여기서는 평균)를 포함하거나 제외합니다. 그러나 반복적으로 표본을 추출하면 신뢰 구간(여기서는 68% 신뢰 구간, 표본 평균 +/- 표준 오차에 해당)이 약 68%의 경우 실제 평균을 포함합니다.

```{r ci-frequentist-expl, fig.asp = 1, fig.cap = '(ref:ci-frequentist-expl)'}
set.seed(85439)
df <- data.frame(y = rnorm(10000))
df_cont <- data.frame(
  x = c(seq(-3, 3, by = 0.02), -3)
) %>%
  mutate(
    y = dnorm(x),
    ny = y/max(y)
  )

spl <- sampler(10, 5, seed = 9382)

ggplot(df, aes(y = y)) +
  geom_polygon(data = df_cont, aes(1.5*ny + 10.5, x), fill = "lightblue") +
  geom_hline(yintercept = 0, linetype = 2, size = 0.5) +
  geom_point(data = spl, aes(x = .draw), size = 2,
             shape = 21, fill = "lightblue") +
  stat_summary(
    data = spl, aes(x = .draw, color = ifelse(stat(ymax) < 0 | stat(ymin) > 0, "외부", "내부")),
    geom = "errorbar", width = 0.2, size = 0.75,
    position = position_nudge(x = -.15)
  ) +
  stat_summary(
    data = spl, aes(x = .draw, color = ifelse(stat(ymax) < 0 | stat(ymin) > 0, "외부", "내부")),
    geom = "point", size = 2.5, position = position_nudge(x = -.15)
  ) +
  annotate(x = 11.7, y = 1, geom = "text", label = "모집단", family = dviz_font_family,
           size = 14/.pt, hjust = 0) +
  annotate(x = 11.1, y = 0.05, geom = "text", label = "평균", family = dviz_font_family,
           size = 12/.pt, hjust = 0) +
  annotate(x = 10.04, y = -Inf, geom = "text", label = "표본", family = dviz_font_family,
           size = 14/.pt, hjust = 0, vjust = 0) +
  annotate(x = 6.9, y = -0.02, geom = "text", label = "CI는 실제 평균을 제외함",
           family = dviz_font_family, size = 12/.pt, hjust = 1, vjust = 1) +
  annotate(x = 8.87, y = 0.23, geom = "text", label = "CI는 실제 평균을 포함함",
           family = dviz_font_family, size = 12/.pt, hjust = 0, vjust = 1) +
  scale_color_manual(values = c("#009E73", "#D55E00"), guide = "none") +
  coord_flip() +
  scale_x_continuous(breaks = 1:10, labels = as.character(10:1), name = NULL, expand = c(0.02, 0)) +
  scale_y_continuous(breaks = NULL, name = NULL, limits = c(-3, 3), expand = c(0, 0)) +
  theme_dviz_hgrid() +
  theme(axis.text.y = element_text(vjust = 0.5))
```

요약하자면 베이즈 신뢰 구간은 실제 모수 값에 대한 진술을 하고 빈도주의 신뢰 구간은 귀무 가설에 대한 진술을 합니다. 그러나 실제로는 베이즈 추정치와 빈도주의 추정치가 종종 매우 유사합니다(그림 \@ref(fig:bayes-vs-ols)). 베이즈 접근 방식의 한 가지 개념적 장점은 효과의 크기에 대한 생각을 강조하는 반면 빈도주의적 사고는 효과가 존재하거나 존재하지 않는다는 이분법적 관점을 강조한다는 것입니다.

(ref:bayes-vs-ols) 평균 초콜릿 평점에 대한 빈도주의 신뢰 구간과 베이즈 신뢰 구간 비교. 두 접근 방식 모두 유사하지만 정확히 동일하지는 않은 결과를 생성함을 알 수 있습니다. 특히 베이즈 추정치는 약간의 축소를 보이는데, 이는 가장 극단적인 모수 추정치를 전체 평균으로 조정하는 것입니다. (스위스에 대한 베이즈 추정치가 약간 왼쪽으로 이동하고 페루에 대한 베이즈 추정치가 해당 빈도주의 추정치에 비해 약간 오른쪽으로 이동한 방식을 확인하십시오.) 여기에 표시된 빈도주의 추정치와 신뢰 구간은 그림 \@ref(fig:mean-chocolate-ratings)에 표시된 95% 신뢰도에 대한 결과와 동일합니다.

```{r bayes-vs-ols, fig.width = 5*6/4.2, fig.asp = 0.6, fig.cap = '(ref:bayes-vs-ols)'}
linear_results <-
  lm(rating ~ location, data = cacao_small) %>%
  emmeans(~ location) %>%
  tidy() %>%
  mutate(model = "OLS")

# 나중에 다시 필요하므로 별도로 저장합니다.
bayes_emmeans <- cacao_mcmc %>%
  emmeans(~ location) %>%
  gather_emmeans_draws()

bayes_results <- bayes_emmeans %>%
  mean_qi() %>%
  to_broom_names() %>%
  mutate(model = "베이즈")

bind_rows(linear_results, bayes_results) %>%
  mutate(model = factor(model, levels = c("베이즈", "OLS"))) %>%
  ggplot(aes(x = estimate, y = reorder(location, estimate), xmin = conf.low, xmax = conf.high, color = model)) +
  ggplot2::geom_errorbarh(position = ggstance::position_dodgev(height = .7), height = 0.2) +
  geom_point(position = ggstance::position_dodgev(height = .7), size = 2.5) +
  scale_x_continuous(
    limits = c(2.6, 3.6),
#    expand = c(0, 0),
    name = "평균 평가"
  ) +
  scale_y_discrete(name = NULL) +
  scale_color_manual(
    name = NULL,
    values = c(
      OLS = "grey40",
      Bayes = desaturate(darken("#0072B2", .2), 0.1)
    ),
    breaks = c("OLS", "베이즈"),
    labels = c("95% 신뢰 구간", "95% 신뢰 구간")
    #guide = guide_legend(direction = "horizontal")
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid(14, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1),
    legend.position = c(1, 0.013),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(15, "pt"),
    legend.key.width = grid::unit(28, "pt"),
    legend.spacing.x = grid::unit(3.5, "pt"),
    legend.spacing.y = grid::unit(14, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )
```


```{block type='rmdtip', echo=TRUE}
베이즈 신뢰 구간은 "실제 모수 값이 어디에 있을 것으로 예상합니까?"라는 질문에 답합니다. 빈도주의 신뢰 구간은 "실제 모수 값이 0이 아니라고 얼마나 확신합니까?"라는 질문에 답합니다.
```

베이즈 추정의 중심 목표는 사후 분포를 얻는 것입니다. 따라서 베이즈주의자들은 종종 신뢰 구간으로 단순화하는 대신 전체 분포를 시각화합니다. 따라서 데이터 시각화 측면에서 챕터 \@ref(histograms-density-plots), \@ref(ecdf-qq), \@ref(boxplots-violins)에서 논의된 모든 분포 시각화 접근 방식이 적용 가능합니다. 구체적으로 히스토그램, 밀도 그림, 상자 그림, 바이올린, 능선 그림은 모두 베이즈 사후 분포를 시각화하는 데 일반적으로 사용됩니다. 이러한 접근 방식은 해당 장에서 자세히 논의되었으므로 여기서는 평균 초콜릿 평점의 베이즈 사후 분포를 보여주는 능선 그림을 사용하는 예 하나만 보여 드리겠습니다(그림 \@ref(fig:bayes-ridgeline)). 이 특정 경우 곡선 아래에 음영을 추가하여 정의된 사후 확률 영역을 나타냈습니다. 음영 대신 분위수 점 그림을 그리거나 각 분포 아래에 등급 오차 막대를 추가할 수도 있었습니다. 아래에 오차 막대가 있는 능선 그림을 반쪽 눈 그림이라고 하고 오차 막대가 있는 바이올린 그림을 눈 그림이라고 합니다(챕터 \@ref(directory-uncertainty)).

(ref:bayes-ridgeline) 능선 그림으로 표시된 평균 초콜릿 바 평점의 베이즈 사후 분포. 빨간색 점은 각 사후 분포의 중앙값을 나타냅니다. 연속 분포를 특정 신뢰 영역으로 변환하기 어렵기 때문에 각 곡선 아래에 음영을 추가하여 각 사후 분포의 중앙 80%, 95%, 99%를 나타냈습니다.

```{r bayes-ridgeline, fig.width = 5*6/4.2, fig.asp = 0.6, fig.cap = '(ref:bayes-ridgeline)'}
bayes_emmeans %>%
  ggplot(aes(.value, reorder(location, .value))) +
  geom_density_ridges_gradient(
    aes(fill = stat(quantile)),
    quantiles = c(0.005, 0.025, 0.1, 0.9, 0.975, 0.995),
    calc_ecdf = TRUE,
    scale = 1.5,
    color = darken("#0072B2", .4),
    size = 0.3,
    rel_min_height = 0.005
  ) +
  geom_point(
    stat = ggstance:::StatSummaryh,
    fun.x = median,
    size = 2.5, color = "#D55E00"
  ) +
  scale_x_continuous(
#    expand = c(0, 0),
    name = "평균 평가"
  ) +
  scale_y_discrete(name = NULL) +
  scale_fill_manual(
    name = "사후 확률",
    values = c(
      "#00000000",
      "#81A7D6A0", # desaturate(lighten("#0072B2", .4), .3)
      "#508CC6A0", # desaturate(lighten("#0072B2", .2), .1)
      "#035B8FA0", # darken("#0072B2", .2)
      "#508CC6A0",
      "#81A7D6A0",
      "#00000000"
    ),
    breaks = c(4, 3, 2),
    labels = c("80%", "95%", "99%"),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom",
      override.aes = list(color = NA)
    )
  ) +
  coord_cartesian(xlim = c(2.6, 3.6), clip = "off") +
  theme_dviz_hgrid(14, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1),
    legend.position = c(1, 0.013),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(14, "pt"),
    legend.key.width = grid::unit(35, "pt"),
    legend.spacing.x = grid::unit(7, "pt"),
    legend.spacing.y = grid::unit(3.5, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title.align = 0.5
  )
```


## 곡선 적합의 불확실성 시각화 {#uncertainty-curve-fits}

챕터 \@ref(visualizing-trends)에서는 데이터에 직선 또는 곡선을 적합시켜 데이터 세트의 추세를 보여주는 방법을 논의했습니다. 이러한 추세 추정치에도 불확실성이 있으며 신뢰대를 사용하여 추세선의 불확실성을 표시하는 것이 일반적입니다(그림 \@ref(fig:blue-jays-male-conf-band)). 신뢰대는 데이터와 호환되는 여러 다른 적합선의 범위를 제공합니다. 학생들이 신뢰대를 처음 접할 때 완벽하게 직선인 적합조차도 곡선인 신뢰대를 생성한다는 사실에 놀라는 경우가 많습니다. 곡률의 이유는 직선 적합이 두 가지 뚜렷한 방향으로 움직일 수 있기 때문입니다. 위아래로 움직일 수 있고(즉, 절편이 다름) 회전할 수 있습니다(즉, 기울기가 다름). 적합 매개변수의 사후 분포에서 무작위로 생성된 여러 대체 적합선을 그려 신뢰대가 어떻게 발생하는지 시각적으로 보여줄 수 있습니다. 이는 그림 \@ref(fig:blue-jays-male-fitted-draws)에서 수행되며 15개의 무작위로 선택된 대체 적합을 보여줍니다. 각 선이 완벽하게 직선임에도 불구하고 각 선의 여러 기울기와 절편의 조합이 신뢰대와 똑같이 보이는 전체 모양을 생성한다는 것을 알 수 있습니다.

(ref:blue-jays-male-conf-band) 그림 \@ref(fig:blue-jays-scatter-line)에서와 같이 수컷 파랑어치의 머리 길이 대 체질량. 직선 파란색 선은 데이터에 대한 최상의 선형 적합을 나타내고 선 주위의 회색 띠는 선형 적합의 불확실성을 보여줍니다. 회색 띠는 95% 신뢰 수준을 나타냅니다. 데이터 출처: 키스 타빈, 오벌린 대학

```{r blue-jays-male-conf-band, fig.width = 5.5, fig.asp = 3/4, fig.cap = '(ref:blue-jays-male-conf-band)'}
blue_jays_male <- filter(blue_jays, KnownSex == "M")

fit <- gam(Head ~ Mass, data = blue_jays_male, method = "REML")

newdata <- data.frame(Mass = seq(59, 82, length.out = 100))

sample_df <- sample_outcomes(fit, newdata, 15, unconditional = TRUE)
ci_df <- confidence_band(fit, newdata, unconditional = TRUE)

ggplot(blue_jays_male, aes(Mass, Head)) +
  geom_ribbon(data = ci_df, aes(ymin = lo, ymax = hi), fill="grey70", color = NA, alpha = 1/2) +
  geom_point(color = "grey60", size = 1.5) +
  #geom_line(data = sample_df, aes(group = .draw), color = "#0072B2", size = 0.3) +
  geom_line(data = ci_df, color = "#0072B2", size = 1) +
  scale_x_continuous(
    limits = c(59, 82),
    expand = c(0, 0),
    name = "체질량 (g)") +
  scale_y_continuous(
    limits = c(52, 61),
    expand = c(0, 0),
    name = "머리 길이 (mm)"
  ) +
  theme_dviz_open()
```

(ref:blue-jays-male-fitted-draws) 수컷 파랑어치의 머리 길이 대 체질량. 그림 \@ref(fig:blue-jays-male-conf-band)와 달리 이제 직선 파란색 선은 사후 분포에서 무작위로 추출된 동일하게 가능한 대체 적합을 나타냅니다. 데이터 출처: 키스 타빈, 오벌린 대학

```{r blue-jays-male-fitted-draws, fig.width = 5.5, fig.asp = 3/4, fig.cap = '(ref:blue-jays-male-fitted-draws)'}

ggplot(blue_jays_male, aes(Mass, Head)) +
  geom_ribbon(data = ci_df, aes(ymin = lo, ymax = hi), fill="grey70", color = NA, alpha = 1/2) +
  geom_point(color = "grey60", size = 1.5) +
  geom_line(data = sample_df, aes(group = .draw), color = "#0072B2", size = 0.3) +
  #geom_line(data = ci_df, color = "#0072B2", size = 1) +
  scale_x_continuous(
    limits = c(59, 82),
    expand = c(0, 0),
    name = "체질량 (g)") +
  scale_y_continuous(
    limits = c(52, 61),
    expand = c(0, 0),
    name = "머리 길이 (mm)"
  ) +
  theme_dviz_open()

```

신뢰대를 그리려면 신뢰 수준을 지정해야 하며 오차 막대 및 사후 확률의 경우와 마찬가지로 여러 신뢰 수준을 강조하는 것이 유용할 수 있습니다. 이는 여러 신뢰 수준을 한 번에 보여주는 등급 신뢰대로 이어집니다(그림 \@ref(fig:blue-jays-male-graded-conf-band)). 등급 신뢰대는 독자의 불확실성 감각을 향상시키고 독자가 데이터가 여러 대체 추세선을 지원할 수 있다는 가능성에 직면하도록 강요합니다.

(ref:blue-jays-male-graded-conf-band) 수컷 파랑어치의 머리 길이 대 체질량. 오차 막대의 경우와 마찬가지로 추정치의 불확실성을 강조하기 위해 등급 신뢰대를 그릴 수 있습니다. 데이터 출처: 키스 타빈, 오벌린 대학

```{r blue-jays-male-graded-conf-band, fig.width = 5.5, fig.asp = 3/4, fig.cap = '(ref:blue-jays-male-graded-conf-band)'}
ci_99_df <- confidence_band(fit, newdata, level = 0.99, unconditional = TRUE)
ci_80_df <- confidence_band(fit, newdata, level = 0.80, unconditional = TRUE)

ggplot(blue_jays_male, aes(Mass, Head)) +
  geom_ribbon(
    data = ci_99_df,
    aes(ymin = lo, ymax = hi, fill = "99%"),
    color = NA
  ) +
  geom_ribbon(
    data = ci_df,
    aes(ymin = lo, ymax = hi, fill = "95%"),
    color = NA
  ) +
  geom_ribbon(
    data = ci_80_df,
    aes(ymin = lo, ymax = hi, fill = "80%"),
    color = NA
  ) +
  geom_point(color = "grey40", size = 1.5) +
  geom_line(data = ci_df, color = darken("#0072B2", .4), size = 1) +
  scale_fill_manual(
    name = "신뢰 수준",
    values = c(
     `80%` = desaturate(lighten("#0072B2", .4), .3),
     `95%` = desaturate(lighten("#0072B2", .6), .3),
     `99%` = desaturate(lighten("#0072B2", .8), .3)
    ),
    guide = guide_legend(
      direction = "horizontal",
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  scale_x_continuous(
    limits = c(59, 82),
    expand = c(0, 0),
    name = "체질량 (g)"
  ) +
  scale_y_continuous(
    limits = c(52, 61),
    expand = c(0, 0),
    name = "머리 길이 (mm)"
  ) +
  theme_dviz_open() +
  theme(
    legend.position = c(1, .01),
    legend.justification = c(1, 0),
    legend.key.height = grid::unit(12, "pt"),
    legend.key.width = grid::unit(30, "pt"),
    legend.spacing.x = grid::unit(6, "pt"),
    legend.spacing.y = grid::unit(3, "pt"),
    legend.box.background = element_rect(fill = "white", color = NA),
    legend.box.spacing = grid::unit(0, "pt"),
    legend.title = element_text(size = 12, hjust = 0.5)
  )
```

비선형 곡선 적합에 대한 신뢰대도 그릴 수 있습니다. 이러한 신뢰대는 보기 좋지만 해석하기 어려울 수 있습니다(그림 \@ref(fig:mpg-uncertain)). 그림 \@ref(fig:mpg-uncertain)a를 보면 파란색 선을 위아래로 움직이고 약간 변형시켜 신뢰대가 발생하는 것으로 생각할 수 있습니다. 그러나 그림 \@ref(fig:mpg-uncertain)b에서 알 수 있듯이 신뢰대는 (a) 부분에 표시된 전체 최적 적합보다 훨씬 더 구불구불한 곡선 계열을 나타냅니다. 이것은 비선형 곡선 적합의 일반적인 원리입니다. 불확실성은 곡선을 위아래로 움직이는 것뿐만 아니라 구불구불함이 증가하는 것에도 해당합니다.

(ref:mpg-uncertain) 32개 자동차(1973~74년 모델)의 연비 대 배기량. 각 점은 하나의 자동차를 나타내며 평활선은 5개의 매듭이 있는 3차 회귀 스플라인을 적합시켜 얻었습니다. (a) 최적 적합 스플라인 및 신뢰대. (b) 사후 분포에서 추출한 동일하게 가능한 대체 적합. 데이터 출처: 모터 트렌드, 1974.

```{r mpg-uncertain, fig.width = 5.5*6/4.2, fig.asp = 3/8, fig.cap='(ref:mpg-uncertain)'}
set.seed(8692282)

fit <- gam(mpg ~ s(disp, bs = 'cr', k = 5), data = mtcars, method = "REML")
#fit <- gam(mpg ~ s(disp, bs = 'ts', k = 6), data = mtcars, method = "REML")

newdata <- data.frame(disp = seq(min(mtcars$disp), max(mtcars$disp), length.out = 100))
sample_df <- sample_outcomes(fit, newdata, 10, unconditional = TRUE)
ci_df <- confidence_band(fit, newdata, unconditional = TRUE)

cars_base <- ggplot(mtcars, aes(x = disp, y = mpg)) +
  scale_x_continuous(
    name = "배기량 (cu. in.)",
    expand = c(0.03, 0)
  ) +
  ylab("연비 (mpg)") +
  theme_dviz_grid(12) +
  theme(plot.margin = margin(6, 1.5, 3, 1.5))

p1 <- cars_base +
  geom_ribbon(data = ci_df, aes(ymin = lo, ymax = hi), fill="grey70", color = NA, alpha = 1/2) +
  geom_point(color = "grey60") +
  geom_line(data = ci_df, color = "#0072B2", size = 1)

p2 <- cars_base +
  geom_ribbon(data = ci_df, aes(ymin = lo, ymax = hi), fill="grey70", color = NA, alpha = 1/2) +
  geom_point(color = "grey60") +
  geom_line(data = sample_df, aes(group = .draw), color = "#0072B2", size = 0.3)

plot_grid(
  p1, NULL, p2, align = 'hv',
  nrow = 1,
  labels = c("a", "", "b"),
  rel_widths = c(1, .02, 1)
)

```



## 가상 결과 그림

불확실성에 대한 모든 정적 시각화는 뷰어가 불확실성 시각화의 일부 측면을 데이터의 결정론적 특징으로 해석할 수 있다는 문제(결정론적 해석 오류)를 안고 있습니다. 여러 가지 다르지만 동등하게 가능한 그림을 순환하여 애니메이션을 통해 불확실성을 시각화함으로써 이 문제를 피할 수 있습니다. 이러한 종류의 시각화를 *가상 결과 그림*[@Hullman_et_al_2015] 또는 HOP라고 합니다. HOP는 인쇄 매체에서는 불가능하지만 GIF 또는 MP4 비디오 형태로 애니메이션 시각화를 제공할 수 있는 온라인 환경에서는 매우 효과적일 수 있습니다. HOP는 구두 발표 맥락에서도 잘 작동할 수 있습니다.

HOP 개념을 설명하기 위해 초콜릿 바 등급으로 다시 돌아가 보겠습니다. 식료품점에서 초콜릿을 살까 생각할 때 특정 초콜릿 바 그룹의 평균 맛 등급과 관련 불확실성은 아마 신경 쓰지 않을 것입니다. 대신 다음과 같은 더 간단한 질문에 대한 답을 알고 싶을 수 있습니다. 캐나다산 초콜릿 바와 미국산 초콜릿 바를 무작위로 고르면 둘 중 어느 것이 더 맛있을 것으로 예상해야 할까요? 이 질문에 답하기 위해 데이터 세트에서 캐나다산 바와 미국산 바를 무작위로 선택하고 등급을 비교하고 결과를 기록한 다음 이 과정을 여러 번 반복할 수 있습니다. 이렇게 하면 약 53%의 경우 캐나다산 바가 더 높은 등급을 받고 47%의 경우 미국산 바가 더 높은 등급을 받거나 두 바가 동점이라는 것을 알 수 있습니다. 여러 무작위 추출 간에 순환하고 각 추출에 대한 두 바의 상대적 순위를 표시하여 이 과정을 시각적으로 보여줄 수 있습니다(그림 \@ref(fig:chocolate-HOP-static)/그림 \@ref(fig:chocolate-HOP-animated)).

(ref:chocolate-HOP-static) (인쇄판용) 캐나다 및 미국산 초콜릿 바 등급에 대한 가상 결과 그림의 개략도. 각 수직 녹색 막대는 하나의 바에 대한 등급을 나타내며 각 패널은 캐나다 제조업체와 미국 제조업체에서 각각 하나씩 무작위로 선택된 두 바의 비교를 보여줍니다. 실제 가상 결과 그림에서는 디스플레이가 여러 플롯 패널을 나란히 표시하는 대신 순환합니다.

```{r chocolate-HOP-static, fig.width = 5.5*6/4.2, fig.asp = 0.6, fig.cap = '(ref:chocolate-HOP-static)'}
cacao %>%
  filter(location %in% c("캐나다", "미국")) %>%
  mutate(location = fct_recode(location, US = "미국")) -> cacao_US_CA

set.seed(49323)
n <- 9
CA_ratings <- sample_n(filter(cacao_US_CA, location == "캐나다"), n, replace = TRUE) %>%
  mutate(.draw = 1:n())
US_ratings <- sample_n(filter(cacao_US_CA, location == "US"), n, replace = TRUE) %>%
  mutate(.draw = 1:n())

sample_df <- rbind(CA_ratings, US_ratings) %>%
  mutate(location = fct_relevel(location, "US", "캐나다"))

ggplot(sample_df) +
  geom_segment(
    aes(
      x = rating, xend = rating,
      y = as.integer(location) - 0.35,
      yend = as.integer(location) + 0.35
    ),
    size = 1.5, color = darken("#009E73", .3)
  ) +
  scale_x_continuous(
    limits = c(1.95, 4.1),
    expand = c(0, 0),
    name = "초콜릿 맛 평가"
  ) +
  scale_y_discrete(
    name = NULL,
    limits = c("US", "캐나다"),
    expand = c(0, 0.25)
  ) +
  theme_dviz_hgrid(12, rel_small = 1) +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    #axis.title.x = element_text(hjust = 1),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank(),
    strip.text = element_blank()
  ) +
  panel_border() +
  facet_wrap(~.draw, scales = "free_x")
```

(ref:chocolate-HOP-animated) (온라인판용) 캐나다 및 미국산 초콜릿 바 등급에 대한 가상 결과 그림. 각 수직 녹색 막대는 하나의 바에 대한 등급을 나타냅니다. 애니메이션은 캐나다 제조업체와 미국 제조업체에서 각각 하나씩 무작위로 선택된 두 바의 여러 경우를 순환합니다.

```{r chocolate-HOP-animated, eval = animate, gganimate = list(nframes = 200), fig.asp = 0.6, fig.retina = 1, fig.cap = '(ref:chocolate-HOP-animated)'}
library(gganimate)

set.seed(49316)
n <- 30

CA_ratings <- sample_n(filter(cacao_US_CA, location == "캐나다"), n, replace = TRUE) %>%
  mutate(.draw = 1:n())
US_ratings <- sample_n(filter(cacao_US_CA, location == "US"), n, replace = TRUE) %>%
  mutate(.draw = 1:n())

sample_df <- rbind(CA_ratings, US_ratings) %>%
  mutate(location = fct_relevel(location, "US", "캐나다"))

ggplot(sample_df) +
  geom_segment(
    aes(
      x = rating, xend = rating,
      y = as.integer(location) - 0.35,
      yend = as.integer(location) + 0.35,
      group = .draw
    ),
    size = 1.5, color = darken("#009E73", .3)
  ) +
  scale_x_continuous(
    limits = c(1.95, 4.1),
    expand = c(0, 0),
    name = "초콜릿 맛 평가"
  ) +
  scale_y_discrete(
    name = NULL,
    limits = c("US", "캐나다"),
    expand = c(0, 0.25)
  ) +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    axis.title.x = element_text(hjust = 1),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank(),
    strip.text = element_blank()
  ) +
  #panel_border() +
  transition_states(.draw, 1, 2)
```

두 번째 예로 그림 \@ref(fig:mpg-uncertain)b의 동일하게 가능한 추세선 간의 모양 변화를 생각해 보십시오. 모든 추세선이 서로 겹쳐 그려지므로 주로 추세선으로 덮인 전체 영역을 인식하며 이는 신뢰대와 유사합니다. 개별 추세선을 인식하기는 어렵습니다. 이 그림을 HOP로 만들면 개별 추세선을 한 번에 하나씩 강조 표시할 수 있습니다(그림 \@ref(fig:mpg-uncertain-HOP-static)/그림 \@ref(fig:mpg-uncertain-HOP-animated)).

(ref:mpg-uncertain-HOP-static) (인쇄판용) 연비 대 배기량에 대한 가상 결과 그림의 개략도. 각 점은 하나의 자동차를 나타내며 평활선은 5개의 매듭이 있는 3차 회귀 스플라인을 적합시켜 얻었습니다. 각 패널의 각 선은 적합 매개변수의 사후 분포에서 추출한 하나의 대체 적합 결과를 나타냅니다. 실제 가상 결과 그림에서는 디스플레이가 여러 플롯 패널을 나란히 표시하는 대신 순환합니다.


```{r mpg-uncertain-HOP-static, fig.width = 5.5*6/4.2, fig.asp = 2/4, fig.cap = '(ref:mpg-uncertain-HOP-static)'}
#set.seed(8692282)
set.seed(8692276)

fit <- gam(mpg ~ s(disp, bs = 'cr', k = 5), data = mtcars, method = "REML")

newdata <- data.frame(disp = seq(min(mtcars$disp), max(mtcars$disp), length.out = 100))
sample_df <- sample_outcomes(fit, newdata, 6, unconditional = TRUE)

ggplot(mtcars, aes(x = disp, y = mpg)) +
  scale_x_continuous(
    name = "배기량 (cu. in.)",
    expand = c(0.03, 0)
  ) +
  scale_y_continuous(
    name = "연비 (mpg)",
    limits = c(8.5, 35),
    expand = c(0, 0)
  ) +
  geom_point(color = "grey60") +
  geom_line(data = sample_df, color = "#0072B2", size = 0.5) +
  facet_wrap(~.draw, scales = "free") +
  theme_dviz_grid(12) +
  theme(
    strip.text = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = unit(0, "pt"),
    plot.margin = margin(6, 1.5, 3, 1.5)
  ) +
  panel_border()
```

(ref:mpg-uncertain-HOP-animated) (온라인판용) 연비 대 배기량에 대한 가상 결과 그림. 각 점은 하나의 자동차를 나타내며 평활선은 5개의 매듭이 있는 3차 회귀 스플라인을 적합시켜 얻었습니다. 애니메이션은 적합 매개변수의 사후 분포에서 추출한 여러 대체 적합 결과를 순환합니다.

```{r mpg-uncertain-HOP-animated, eval = animate, fig.width = 5.5, fig.asp = 3/4, fig.retina = 1, fig.cap = '(ref:mpg-uncertain-HOP-animated)'}
library(gganimate)

#set.seed(8692282)
set.seed(8692276)

fit <- gam(mpg ~ s(disp, bs = 'cr', k = 5), data = mtcars, method = "REML")

newdata <- data.frame(disp = seq(min(mtcars$disp), max(mtcars$disp), length.out = 100))
sample_df <- sample_outcomes(fit, newdata, 20, unconditional = TRUE)

ggplot(mtcars, aes(x = disp, y = mpg)) +
  scale_x_continuous(
    name = "배기량 (cu. in.)",
    expand = c(0.03, 0)
  ) +
  scale_y_continuous(
    name = "연비 (mpg)",
    limits = c(8.5, 35),
    expand = c(0, 0)
  ) +
  geom_point(color = "grey60") +
  geom_line(data = sample_df, aes(group = .draw), color = "#0072B2", size = 0.5) +
  theme_dviz_grid() +
  theme(
    strip.text = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = unit(0, "pt"),
    plot.margin = margin(7, 1.5, 3.5, 1.5)
  ) +
  panel_border() +
  transition_states(.draw, 0, 1)
```

HOP를 준비할 때 여러 결과 간에 하드 스위치(슬라이드 프로젝터에서와 같이)를 만드는 것이 더 나은지 아니면 한 결과에서 다른 결과로 부드럽게 애니메이션(예: 한 결과의 추세선이 다른 결과의 추세선처럼 보일 때까지 천천히 변형)하는 것이 더 나은지 궁금할 수 있습니다. 이것은 어느 정도 계속 연구되고 있는 미해결 문제이지만 일부 증거에 따르면 부드러운 전환은 표현된 확률에 대한 판단을 더 어렵게 만듭니다[@Kale_et_al_2018]. 결과 간 애니메이션을 고려하는 경우 이러한 애니메이션을 매우 빠르게 만들거나 결과가 서로 변형되는 대신 페이드 인 및 페이드 아웃되는 애니메이션 스타일을 선택하는 것이 좋습니다.

HOP를 준비할 때 주의해야 할 중요한 측면이 하나 있습니다. 표시하는 결과가 가능한 결과의 실제 분포를 대표하는지 확인해야 한다는 것입니다. 그렇지 않으면 HOP가 상당히 오해의 소지가 있을 수 있습니다. 예를 들어 초콜릿 등급의 경우로 돌아가서 초콜릿 바의 10개 결과 쌍을 무작위로 선택하고 그중 7개 경우에 미국 바가 캐나다 바보다 높은 등급을 받았다면 HOP는 미국 바가 캐나다 바보다 높은 등급을 받는 경향이 있다는 잘못된 인상을 줄 것입니다. 표본 추출 편향이 발생할 가능성이 없도록 매우 많은 수의 결과를 선택하거나 표시되는 결과가 적절한지 어떤 형태로든 확인하여 이 문제를 방지할 수 있습니다. 그림 \@ref(fig:chocolate-HOP-static)/그림 \@ref(fig:chocolate-HOP-animated)을 만들 때 캐나다 바가 이기는 것으로 표시된 횟수가 실제 백분율인 53%에 가까운지 확인했습니다.
